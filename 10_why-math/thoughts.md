В чём состоит работа математика?
Он исследует, внимательно изучает некоторый реальный или абстрактный объект,
а затем делает некоторое утверждение о нём, то есть гипотезу.
А дальше пытается либо построить контрпример, либо построить доказательство.

То есть он задействует логический и аналитический аппарат, чтобы установить связи между разными фактами, возможно
через построение промежуточных абстракций, доказательство свойств этих абстракций и построения на их основе новых абстракций.

Перевёрнутая пирамида.

Искусственный интеллект начнёт вытеснять всех решателей тривиальных задач.

Программисты редко решают задачи для самих себя:
мы работаем в банковских сервисах,
сервисах бронирования отелей,
картографических сервисах,
музыкальных, социальных, наукоёмких и разных финансовых.

Фронтовые задачи обычно связаны с интеграцией со сторонними библиотеками. "Как заставить эту сволочь работать!".

Получается, что мы решаем задачи наших пользователей, иногда наши пользователи - это другие программисты, но как правило
решеаемые задачи связаны с какой-то предметной областью. Для решения задач у нас есть алгоритмы, языки программирования,
библиотеки для языков программирования с реализованными алгоритмами, выработанные практики наилучших решений, паттерны и
многочисленные примеры плохих решений, которые желательно избегать.

Для программиста важно понимать, как работает система в целом. Таким образом, в процессе создания системы придётся
стать немного специалистом и в области, для которой система предназначена.

Есть ли область знаний, которая нужна всем программистам без исключения?
Да, и это математика, и конкретно несколько разделов:
1. Школьная математика, понятие функции, преобразование алгебраических выражений. 
2. Логика, чтобы корректно преобразовывать и упрощать булевы выражения.
3. Алгоритмы и структуры данных.
возможно имеет смысл зарулить в лямбда-исчисление и теорию алгоритмов. Это может понадобиться, когда вы предоставляете
какую-то скриптовую поддержку и не хотите, чтобы пользователь смог сделать что-то плохое, или наоборот, предоставить
ему достаточно богатый базис.

Проблема 4х красок, машинное доказательство, Coq.

Создание систем на сильно типизированных языках гораздо больше похоже на доказательство теорем, вспомнить про
измоморфизм Карри-Говарда.

Умение оценить эффективность алгоритмов поможет вам писать код, который будет хорошо работать в условиях огранниченных
ресурсов и позволит строить на их основе системы, которые не требуют чрезмерное количество ресурсов.

Есть большое различие между программистом, который только использует какое-то апи, и программистом, который пишет библиотечный
или коре код, на основе которого остальные будут строить свои вещи.

Чем больше система, тем время затрачиваемое на создание экспоненциально больше. Условно говоря, если провести аналогию
со строительством, первый кирпич вы кладёте за минуту, а тысячный вам требуется не менее месяца.

У программистов обычно другой челлендж - им нужно справиться с всё воозрастающей
сложностью программных систем.

Михаил Ломоносов: "Математику только затем учить надо, что она ум в порядок приводит"
Александр Суворов: "Математика - гимнастика ума"

Программирование -- это прикладная специальность. Написание кода не является самоцелью,
программирование это способ описания и исследования моделей.
Программирование не может идти в отрыве от какой-то другой области.

Главное в программировании - это решение задач (а не написание кода!).

Маркетинговое исследование воронки продаж бессмысленно, если у нас нет магазина, штуковин для продажи и тех,
кому это надо продавать.

Я старался избегать вещей, связанных с SQL, при этом моё время столкновения совпало  

Анимации, кривые Безье, трансформации в CSS тоже требуют определённого понимания декартовых координат и векторов.

в общем, математика и вообще сильные теоретико-фундаментальные знания (да простят меня все приверженцы старой школы)
нужны для разработки чего-то нового и/или низкоуровневого, например: библиотек под новые инструменты, каких-то 
специализированных вычислительных алгоритмов и т.д. скорее всего вы будете пользоваться всем уже написанным, 
потому что это проще и эффективнее ) а захотите что-то новое или свое написать, тогда и подтяните что нужно, 
но не думайте что это так просто )) сначала научитесь пользоваться уже созданным. я бы уделил время такой 
«базе»: работе компиляторов, структурам данных и алгоритмам, архитектуре, стандартам и принципам написания 
хороших приложений и считайте минимум год у вас уже занят или минимум жизнь, смотря на сколько глубоко нырять)



```
L | L L | \x -> L
(\x -> M) N => M[x := M]
```
