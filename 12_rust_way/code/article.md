# Что такое `Pin` в Rust

Целью этой статьи является собрать и последовательно показать с самого начала какую задачу решает
`Pin`, в чём идея и как именно реализована эта идея и какие подводные камни пришлось обходить разработчикам
языка Rust в процессе реализации.

Вся эта статья является в конечном итоге компиляцией стандартной документации,
блог-постов и выступлений Лодочника (известный в Rust-сообществе человек), видеостримов Джона (Jon Gjengset,
два стрима общей длительностью более 7 часов!) и других более мелких источников.

Если вы уже успели обозреть всё выше, то вам эта статья не нужна, вы и так всё знаете. Если же вы
хотите более подробно изучить Rust, или давно уже пишете сетевые приложения на Rust с 
использованием async/await, но пока у вас не нашлось времени разобраться с `Pin` более подробно, то
добро пожаловать.

## Как вернуть сложный объект из функции

На первый взгляд вопрос достаточно простой. Однако мы знаем, что в Rust нет сборщика мусора (такого,
наподобие как в Go/Java/C#), и поневоле встаёт вопрос управления памятью. Если возвращать просто целое
число, то его можно просто скопировать. Но если возвращать вектор, то копирование вещь чересчур
расточительная, и мы должны как-то избежать копирования всего набора чисел, которые этот вектор содержит.

Решением, принятым в Rust является выделение буфера под набор чисел в динамической памяти и _перемещение_
только объекта `Vec`, который представляет собой просто три поля: длину, вместимость и указатель на буфер.
Перемещение в сущности есть просто побитовое копирование объекта, но при этом компилятор "держит в уме" то, 
что место откуда скопированы данные отныне "забыто", обращаться к ним больше нельзя и этот факт проверяется на этапе компиляции.

Перемещение может осуществляться не только при возврате из функции, а также при передаче в функцию по
значению и ряде других операций. Область видимости, куда перемещается объект становится новым владельцем
этого объекта и отвечает за его (объекта) удаление. Подробнее об это можно глянуть в соответствующей главе
[Rust на примерах](https://doc.rust-lang.ru/stable/rust-by-example/scope/move.html) и в 
книге [Язык программирования Rust](https://doc.rust-lang.ru/book/ch04-00-understanding-ownership.html).

```
use std::mem;

fn mutate_vec(mut v: Vec<i32>) -> Vec<i32> {
    v.push(42);
    v
}

fn main() {
    let xs = vec![1, 2, 3];
    let ys = mutate_vec(xs);
    let mut zs = ys;
    // обращаться к xs и ys теперь нельзя, объект был перемещён в zs
    // мы можем создать новый объект vec![4, 5], 
    // переместить новый объект в zs, а старый назвать ws
    let ws = mem::replace(&mut zs, vec![4, 5]);
    println!("zs = {:?}, ws = {:?}", zs, ws);
}
```

## Возвращение вектора из `create_vec` под увеличительным стеклом

Будучи (в том числе) низкоуровневым императивным языком, Rust использует главным образом 2 вида памяти: 
кучу и стек, вызовы функций и возвращаемые значения передаются через стек, данные объектов хранятся в куче,
доступ к данным осуществляется через указатели (разумеется, сейчас используются различные оптимизации с 
[передачей через регистры](https://github.com/rust-lang/rust/issues/26494), есть также статическая и другие виды
памяти, но эти ньюансы не повлияют на справедливость рассуждений ниже).

Как было уже раньше сказано, объект типа `Vec` это тройка (длина, вместимость, указатель на буфер). 
В самом начале 
