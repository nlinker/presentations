# What Java can learn from Haskell and vice versa

Привет.

Мы используем Хаскелл на одном из проектов, кода на Хаскеле достаточно много
и на нём реализованы важдые фичи приложения.
Однако мы не достигли Нирваны, и к моему сожалению кодовая база на Хаскеле
не будет расширяться дальше, то есть новые сервисы скорее всего не будем
писать на Хаскеле. Почему у нас не получилось также, как у Facebook,
Standard Chartered, New York Times, AT&T, Zalore и прочих умных мальчиков и девочек?
Давайте разберёмся.

Меня зовут Линкер Николай, и я работаю адептом всего математически прекрасного в компании Иссарт.

Есть отличное видео "Haskell is Not For Production and Other Tales" от
Фейсбуковской шайки, где они разбирают многие моменты, с которыми столкнулись
и мы. Ссылка на видео будет в конце.

Итак, что такое Хаскелл? Хаскелл - достаточно зрелый язык программирования,
функциональный, чистый, ленивый с продвинутой системой типов. Он довольно
быстро развивается, так что ещё тот Хаскелл, что был год-два назад уже весьма
отличается - в 8-й версии ещё потюнили рантайм и реализовали несколько важдных
расширений.

Будучи достаточно новаторским он естественно очень непривычен для программиста
пришедшего из обычных, ООП языков. Я однако поработав продолжительное время на Хаскеле и
в текущий момент пиля фичу на Джаве чувствую себя неуютно и многих вещей мне не хватает.
С другой стороны, есть нечто и в Джаве, что было бы неплохо иметь в Хаскеле.
Вот об этом и погворим.

## TS;DR;

Итак первая вещь, которая меня весьма привлекает и по которой я скучаю в Джаве - это компактный и
(почти) неизбыточный синтаксис.
Определить функцию в Хаскеле - это как 2 байта переслать:

```haskell
size :: Num a => [t] -> a
size xs = loop xs 0
  where
    loop [] acc = acc
    loop (_ : xs) acc = loop xs (acc + 1)

-- Usage
size [1,2,3]
```
Отсюда видно, что при объявлении функций можно не указывать почти никакие типы, Хаскель
их выведет сам. Параметры перечисляются через пробел и идут непосредственно за именем
функции, return не нужен, так как возвращаемое значение - это значение выражения после знака `=`
В тип функции size полиморфный от типа элемента списка, значением

Описание типа выглядит всегда как-то так:
f :: (X a, Y b, Z c) => a -> b -> c


## Чистота - залог здоровья

Вторая вещь, и она главнее первой, которая прямо пронизывает Хаскель насквозь, это чистота.
Без компромиссов. Без болеутоляющих таблеток. Без вариантов.
Все функции в Хаскеле чистые, и обычно это понятно для простых функций вроде конкатенации строк,
но как можно быть чистым, если надо обратиться к файловой системе или что-то напечатать на экране?
Ответ в том, что все функции хоть и чистые, но имеют разный тип, и обойти систему типов создав
побочный эффект там, где идут чистые вычисления Хаскелл не даст.

Чистота означает в частности то, что нет неинициализированных указателей, нулей и
непредвиденных изменений объектов, которые мы не ждали.

Чистые функции преобразуют одно состояние к другому.
MVCC делает инкрементальное изменение
Объект - фукнция которую называют методом примотана скотчем к объекту, и меняет его состояние,
причём доступа к прошлому состоянию уже нет. Проблема коровы и травы.

Давайте рассмотрим пример:
```java
long getLength(String str) { return str.length(); }
long getFileLength(String path) { return new File(path).length(); }
```
И первая, и вторая функции принимают некоторую строку и возвращают целое число.
Но значит ли это, что эти функции взаимозаменяемы? Что везде, где подходит
getLength можно вставить и getFileLength?
Нет!
Несмотря на кажущееся сходство разница между этими фнукциями принципиальная:
первая функция работает всегда, выдаёт всегда один и тот же ответ (если
сам компьютер физически исправен), вторая же функция
1. может упасть
2. может вернуть разное значение в зависимости от момента времени
Вот эти вещи - зависимости конкретной функции, которые _неявно_ влияют на её
выполнение и результат и называются побочными эффектами.

И для того, чтобы писать корректные программы нам надо как-то отличать функции
с эффектами от без эффектов. Более того, желательно и эффекты различать между собой.
И тут естественным образом нам и поможет система типов.
Итак, в Хаскеле все функции формально чистые, просто они имеют разный тип.

## Типы - наше всё

Вторая главная вещь, которая является неотъемлемой частью языка это сильная типизация.
Особенно хочется отметить

- newtypes: wrapping can be free
- ADT & pattern matching
- Классы типов

Иногда мы сталкиваемся с необходимостью отличать миллисекунды от секунд,
пароли от юзернеймов, пути от содержимого по этим путям, индексы друг от друга и так далее.
Все эти кейсы опасны тем, что можно случайно спутать одно с другим. Например,
```java
// call this as runScript("sql/RunStuff.sql")
Result runScript(String script)
int combine(int x, int y, int a, int b)
```
В Хаскеле есть простое и элегантное решение этой проблемы:
```haskell
newtype Path = Path String

runScript :: Path -> IO Result

newtype X = X Integer
newtype Y = Y Integer
newtype A = A Integer
newtype B = B Integer

combine :: X -> Y -> A -> B -> Integer
combine x y a b = ...
```

Что интересно, этот враппер для системы типов выглядит как совершенно новый тип, однако
на уровне компилированного кода этот тип неотличим от внутреннего, например в случае Path
этот тип не имеет никакого оверхеда (ни по перфомансу, ни по памяти) по сравнению с String.

ADT, то есть Алгебраические типы данных - это штука составленная из обычных типов с помощью операций
_и_ и _или_ и названная каким нибудь именем, а паттерн-матчинг позволяет естественным образом
разбирать значение данных типов. Например:

```haskell
data Void
data X = X
data Y = Y Int Text X
data Z = Zx X | Zy Y
data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
data User = User { id :: Int, name :: Text, dutyDay :: Day }
```
Теперь если у нас есть значение, то разобрать его можно так:
```haskell
let z = Zy (Y 123 "Hey" X)
let u1 = User { id = 1, name = "Vasya" }
let u2 = User 2 "Petya"
let d = Sat

case d of
  Mon | Tue | Wed | Thu | Fri -> "Working days"
  Sat | Sun -> "Weekend days"

case u1 of
  User id name -> ...
```
Что интересно, в Хаскеле для представления данных нет больше никаких других типов.
То есть любое нечто, которое содержит хотя бы какой-то байтик или полбайтика, у него
под капотом содержится какой-то алгебраический тип данных. На эти АДТ потом могут быть
навешаны какие-то классы типов или ньютайпы

Эти вещи используются повсеместно, особенно полезен паттерн-матчинг при разборе сложных выражений,
и особненно приятно, что если я забуду какой-то случай, компилятор мне об этом скажет.

Класс типов - это удивительно полезная штука, это в чём-то похоже на джавовские интерфейсы,
но в отличие от них классы типов не прибиты гвоздями ни к какому из типов.
Давайте я приведу пример. Допустим у нас есть тип User
```haskell
data User = User { id :: Int, name :: Text }
```
`User` в начале - это название типа, а в конце - это конструктор
так что мы можем создать юзеров

```haskell
let u1 = User { id = 1, name = "Vasya" }
let u2 = User 2 "Petya"
```
Это простые значения, на данный момент их нельзя даже сравнить.

Теперь на этот тип можно навесить интерфейсы:
Show - чтобы можно было конвертнуть его в строку (чтобы например показать на экране)
Eq - чтобы можно было сравнивать
ToJSON - чтобы можно было преобразовать его в json

Когда мы навесили новые интерфейсы (в терминологии классы типов), с этими значениями u1 и u2 уже можно
делать определённые вещи:
> [show u1, show u2]
> u1 == u2
> encode u1

Это навешивание новых классов на уже существующие типы оказывается довольно мощным средством дизайнить
систему. Теперь уже не нужно пытаться включать оракул и предсказать, какие фичи должен нести тот или иной тип.
Достаточно описать только данные, которые нужны для представления сущностей, а поведение будет навешано
как бы снаружи.

Половина знаний устаревает каждые 10 лет, поэтому нужно концентрироваться на фундаментальном.

+ Компактный и неизбыточный синтаксис
+ no nulls
+ карринг
+ immutable
+ functions as a foundation are good, because they are composable
  int getLength(String x)
  int getFileLength(String paht)
+ subtype polymorphism vs parametric polymorphism
+ haskell repl
+ haskell stack
+ concurrency
+ type classes, gradual typing не решение
+ types, any function a -> b, despite Function22<T1,T2,T3...,R>
+ Известные компиляторы, написанные на Хаскелл: GHC, Corrode, Elm, Agda, Kaleidoscope, Purescript, Pandoc.
+ IO monad это root в мире монад, а liftIO - как sudo


- плохая документация кроме самых популярных библиотек.
- несмотря на то, что чистота является сильным ограничением, мы можем продвинуться достаточно далеко в поддержании чистоты.
- зачем все эти сложности? мы хотим просто писать код
- время на навык расшифровки сообщений об ошибках (No instance for (Num [Char]) arising from a use of '+')
- current date


* в сфере разработки ПО мы имеем дело скорее не с драконом, которого надо победить, а с грязью или микробами. Когда в принципе все бегают туда-сюда с тряпками и вениками, но при этом постоянно оставляют следы на полу - это называется технический долг. А рефакторинг в данном контексте - это генеральная уборка.
* Куда двигаться дальше? Rust.
* Но зачем изучать? Чтобы видеть в мешанине объектов более фундаментальные вещи.
	Фабрика - это функция
	Декоратор - это каррированная функция
	в джаве целая куча классов
	Optional<T>, List<T>, Future<T>, CompletableFuture<T> и у каждого свой собственный API для
* Какое нафиг АОП? Аспекты - это ещё один костыль, который причём начинён хорошей пачкой тротила.
  Свободные монады, они по-меньшей мере сочетаются.


http://bob.ippoli.to/python-haskell-ep2014/#/nonsense-instance
http://www.slideshare.net/KatieAtie/haskell-is-not-for-production-and-other-tales

> I've seen CSP defined as Actors with a mailbox size of 0. Is that a bad definition?
> Yes, bad. By either Carl Hewitt's definition of actors or Erlang's. CSP allows local, anonymous, concurrent routing, that's it. Actors are a location transparent, supervised abstraction that can do routing without anonimity.

### Разговоры про монады

Но как всё-таки печатать на экране?
Пусть у нас есть функция на джаве:

```java
public static IO<Void> main(String[] args) {
    System.out.println("Hello");
    System.out.println("World");
}
```
Я думаю всем понятно, что она делает.
А теперь на секунду представим, что она возвращает не void, а массив функций
```java
new Object[]{
  () -> System.out.println("Hello"),
  () -> System.out.println("World")
}
```
и среда выполнения, сама JVM идёт по этому массиву и выполняет функции одну за одной.
Что мы получим? А мы получим то, что `main` _всегда_ возвращает один и тот же массив.
То есть функция main чистая. Однако результат выполнения будет являться побочным эффектом в
виде пары строк "Hello" и "World".

Давайте слегка расширим пример.
```java
public static void main(String[] args) {
  if (Random.nextBool())
    System.out.println("Hello");
  else
    System.out.println("World");
}
```
Что в этом случае будет возвращаемым значением? В этом случае это будет немного более сложный массив:
```java
new Object[]{
  () -> Random.nextBool(),
  r -> { if (r) System.out.println("Hello") else System.out.println("World") }
}
```
И в этом случае функция main чистая, она возвращает каждый раз один и тот же массив функций.
Однако результат выполнения этого массива будет зависеть от того, что там выпало из рэндома.

Именно это и делает Хаскель, разве что вместо массива там более сложная структура данных,
ациклический граф, построенный как последовательность вложенных лямбд
склеенных операцией bind из класса типов Monad.

Ну давайте посмотрим на предыдущий пример, но на Хаскеле:
```haskell
main :: IO ()
main = do
  x <- getRandom :: IO Bool
  if x
    then putStrLn "Hello"
    else putStrLn "World"
```
И результатом вычисления этой функции является следующая структура данных:
```haskell
getRandom >>= (\x -> if x then putStrLn "Hello" else putStrLn "World")
```
и это является рассахариванием синтаксиса do.

Эта вложенная структура хороша тем, что как её не выполняй: последовательно,
параллельно, лениво, энергично - любое выполнение всегда будет давать один и
тот же порядок совершаемых эффектов.

> The term `monad` is a bid vacuous if you are not a mathematician.
  An alternative term is `computation builder`

Вообще название "computation builder" отражает гораздо лучше назначение таких типов - с помощью
монад вы фактически строите выражения, вот эти ациклические графы, которые потом когда-нибудь
выполняются.

Некоторые монады можно выполнить непосредственно, если они возвращают чистое значение
(такие как Maybe, List, Either, Random, State), а IO (это как бы sudo в мире монад) выполняет сама среда выполнения.
То есть формально мы оставили функцию main чистой, но по своей сути она таковой не является.
И в Хаскеле поэтому стараются как можно больше вычислений вынести за пределы IO и завязанных на
них монад, потому что чистые вычисления вы можете делать где угодно и когда угодно, а то что требует
IO может быть выполнено только в IO.

И в стремлении сделать как можно больше вычислений за пределами IO хаскелисты продвинулись довольно
далеко. В последних статьях о современной архитектуре ФП любая программа представляет собой просто
структуру данных, значение некоторого алгебраического типа и в IO вынесен только очень тонкий слой
фактически одна функция - интерпретатор этой структуры данных.
А в тестах вы имеете другой интерпретатор, который на IO никак
не завязан. Какие преимущества? Вам не нужны моки, код для тестов компактный и чистый. Вы можете
прозрачно навешивать новые аспекты: логгинг, мониторинг и другие вещи просто вызывая соотвествующий
интерпртетатор.

На первый взгляд это кажется лишено смысла - зачем передавать описание того, что хочешь выполнить вместо
того чтобы просто выполнить? Это даёт гибкость и безопасность и потому так делают многие среды,
в том числе и Джава, и ядро Линукса. Например, чтобы сделать системный вызов в Линукс, вам нужно
сформировать корректное описание вызова и сказать ядру с помощью специального прерывания:
"Вот данные для вызова, пожалуйста сделай его". Просто получить функцию в ядре и вызвать его
вам никто не даст, иначе это была бы огромная дыра в безопасности.
